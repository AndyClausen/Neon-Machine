local args={...}
if #args ~= 1 then
	error( 'Usage: edit <filename>', 0 )
end

local lines={''}
local path = shell.getCurrentDir()..args[1]

if fs.exists( path ) then
	local file=fs.open( path, 'r' )
	local ln = 1
	for line in file:lines() do
		lines[ln]=line
		ln=ln+1
	end
	file:close()
end

local mouseImg = gfx.loadImage( 'rom/mouse.img' )

local cursorX = 0
local currLine = 1
local showLines = 1
sys.setKeyRepeat( true )

local GREEN = { 2, 10, 2 }
local DARKER = { 13, 13, 13 }

local sec = 0
local col = 15
local updateCursor = false
local updateCursorCol = 0
local function drawCursor( offset, y )
	local num = offset+cursorX
	local s = os.date("%S")
	if s ~= sec or updateCursor then
		sec = s
		if updateCursor == true then
			col = 15
		else
			if col == 15 then
				col = 0
			else
				col = 15
			end
		end
	end
	gfx.drawLine( num, y+5, num+2, y+5, { col, col, col } )
end

local function calc( a )
	local b = 0
	while b < a do
		b = b + 4
		if b == a then
			return a
		end
	end
	return b - 4
end

local currIndent = "LUA"
local bottom = false
local CKEYWORD = {12,1,8}
local CNUMBER = {8,2,13}
local CDATA = {8,2,13}
local CCOMMENT = {6,6,5}
local CSTRING = {15,13,0}
local CTEXT = {14,14,14}
local COTHER = {12,1,8}
local CFUNC = {0,7,11}
local CLUASTRCONCAT = {12,1,8}
local CLUAARGS = {8,2,13}

local KEYWORDS = {
	[ "LUA" ] = {
		-- Keywords
		[ "local" ] = CKEYWORD;
		[ "while" ] = CKEYWORD;
		[ "for" ] = CKEYWORD;
		[ "if" ] = CKEYWORD;
		[ "do" ] = CKEYWORD;
		[ "then" ] = CKEYWORD;
		[ "else" ] = CKEYWORD;
		[ "elseif" ] = CKEYWORD;
		[ "end" ] = CKEYWORD;
		[ "in" ] = CKEYWORD;
		[ "until" ] = CKEYWORD;
		[ "repeat" ] = CKEYWORD;
		[ "return" ] = CKEYWORD;
		[ "function" ] = CKEYWORD;
		[ "break" ] = CKEYWORD;

		-- Logic
		[ "and" ] = CKEYWORD;
		[ "or" ] = CKEYWORD;
		[ "not" ] = CKEYWORD;

		
		-- Data structures
		[ "true" ] = CDATA;
		[ "false" ] = CDATA;
		[ "nil" ] = CDATA;

	}
}

local function tryWrite( x, y, sLine, regex, clr, minusOne )
	local match = string.match( sLine, regex )
	if match then
		if minusOne then
			match = match:sub( 1, #match-1 )
		end
		if type( clr ) == "function" then
			gfx.print( match, x, y, clr( match ) )
		else
			gfx.print( match, x, y, clr )
		end
		return {string.sub( sLine, string.len(match) + 1 ), x+(string.len(match)*4)}
	end
	return nil
end

local function writeHighlighted( x, y, sLine )
	while string.len(sLine) > 0 do
		local tbl = 
			tryWrite( x, y, sLine, "^%-%-%[%[.-%]%]", CCOMMENT ) or
			tryWrite( x, y, sLine, "^%-%-.*", CCOMMENT ) or
			tryWrite( x, y, sLine, "^\"\"", CSTRING ) or
			tryWrite( x, y, sLine, "^\".-[^\\]\"", CSTRING ) or
			tryWrite( x, y, sLine, "^\'\'", CSTRING ) or
			tryWrite( x, y, sLine, "^\'.-[^\\]\'", CSTRING ) or
			tryWrite( x, y, sLine, "^%[%[.-%]%]", CSTRING ) or
			tryWrite( x, y, sLine, "^%d+", CNUMBER ) or
			tryWrite( x, y, sLine, "^[%+%-%*/%%%^%#%=%<%>%~]+", COTHER ) or
			tryWrite( x, y, sLine, "^(%.%.%.)%.+", CTEXT ) or
			tryWrite( x, y, sLine, "^(%.%.%.)", CLUAARGS ) or
			tryWrite( x, y, sLine, "^(%.%.)", CLUASTRCONCAT ) or
			tryWrite( x, y, sLine, "^[%w_]+%(", CFUNC, true ) or
			tryWrite( x, y, sLine, "^[%w_]+", function( match )
				local curr = KEYWORDS[ currIndent ]
				if curr[ match ] then
					return curr[ match ]
				end
				return CTEXT
			end ) or
			tryWrite( x, y, sLine, "^[^%w_]", CTEXT )
		if tbl then
			sLine = tbl[ 1 ]
			x = tbl[ 2 ] or x
		end
	end
end

while true do
	coroutine.yield()
	local mx, my = sys.getMousePos()
	gfx.clear()
	local currX = (math.floor(#lines/10)*4)
	local lastInput=lines[currLine]
	gfx.drawFillRect( 0, gfx.height-7, gfx.width-1, 7 )
	local h = font.getHeight()+1
	for i=showLines, #lines+(showLines-1) do
		local y=(i-1)*h
		gfx.print( i, 0, y )
		--gfx.print( lines[ i ], 8+currX, y )
		writeHighlighted( 8+currX, y, lines[ i ] )
	end
	gfx.drawLine( 5+currX, 0, 5+currX, gfx.height )
	if sys.keyPressed( 'lctrl' ) then
		bottom = not bottom
	end
	if bottom == false then
		if sys.mousePressed( 1 ) then
			local tx = mx-8-currX
			currLine = math.round((my/6)+.5)
			if currLine > #lines then
				currLine = #lines
			elseif currLine <= 0 then
				currLine = 1
			end
			lastInput=lines[currLine]
			sys.textInput = lastInput
			if tx >= 0 and tx < #lastInput*4 then
				cursorX = calc( tx )
			elseif tx >= #lastInput*4 then
				cursorX = #lastInput*4
			end
			updateCursor = true
		end

		if sys.keyPressed( "up" ) then
			if currLine > 1 then
				currLine = currLine - 1
				if cursorX > #lines[currLine]*4 then
					cursorX = #lines[currLine]*4
					lastInput = lines[currLine]
					sys.textInput = lines[currLine]
				else
					lastInput = lines[currLine]
					sys.textInput = lines[currLine]
				end
				updateCursor = true
			end
		elseif sys.keyPressed( "down" ) then
			if currLine < #lines then
				currLine = currLine + 1
				if cursorX > #lines[currLine]*4 then
					cursorX = #lines[currLine]*4
					lastInput = lines[currLine]
					sys.textInput = lines[currLine]
				else
					lastInput = lines[currLine]
					sys.textInput = lines[currLine]
				end
				updateCursor = true
			end
		elseif sys.keyPressed( "left" ) then
			if cursorX > 1 then
				cursorX = cursorX - 4
				updateCursor = true
			end
		elseif sys.keyPressed( "right" ) then
			if cursorX < #lastInput*4 then
				cursorX = cursorX + 4
				updateCursor = true
			end
		elseif sys.keyPressed( "return" ) then
			local cx = math.floor(cursorX*(1/4))
			local half = lines[currLine]:sub( cx+1, #lines[currLine] )
			lines[currLine]=lines[currLine]:sub(1, cx)
			currLine = currLine + 1
			table.insert( lines, currLine, half )
			sys.textInput = half
			lastInput = half
			cursorX = 0
		elseif sys.keyPressed( "backspace" ) then
			local cx = math.floor(cursorX/4)
			if cx >= 1 then
				local left = lastInput:sub( 1, cx-1 )
				local right = lastInput:sub( cx+1 )
				sys.textInput = left..right
				cursorX = cursorX - 4
				lines[currLine]=sys.textInput
				updateCursor = true
			else
				if #lines > 1 then
					updateCursor = true
					local tmp = lines[ currLine ]
					currLine = currLine - 1
					table.remove( lines, currLine + 1 )
					local x = (#lines[ currLine ] * 4)
					if x <= 0 then
						cursorX = 0
					else
						cursorX = x
					end
					lines[ currLine ] = lines[ currLine ]..tmp
					sys.textInput = lines[ currLine ]
					lastInput = lines[ currLine ]
				end
			end
		elseif sys.keyPressed( "tab" ) then
			sys.textInput = sys.textInput .. "\t"
		else
			if lines[currLine] ~= sys.textInput then
				local cx = math.floor(cursorX*(1/4))
				local len = #sys.textInput
				local left = lastInput:sub( 0, cx )..sys.textInput:sub( len, len )
				local right = lastInput:sub( cx+1 )
				sys.textInput = left..right
				lines[currLine] = sys.textInput
				cursorX = cursorX + 4
			end
		end
		drawCursor( currX+8, (currLine*h)-h )
		updateCursor = false
	else
		local highlightSave = false
		local highlightClose = false
		gfx.print( "Save", 1, gfx.height-6, GREEN )
		if mx >= 21 and mx < 38 then
			highlightClose = true
		else
			highlightClose = false
		end
		if highlightClose == true then
			if sys.mousePressed( 1 ) then
				gfx.clear()
				sys.textInput = ''
				error()
			end
			gfx.drawFillRect( 20, gfx.height-6, 21, 5, DARKER )	
		end
		gfx.print( "Close", 21, gfx.height-6, GREEN )
	end
	gfx.drawImage( mouseImg, mx, my )
end



